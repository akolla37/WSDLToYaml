/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2019
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

var _ = require('lodash');
const u = require('../lib/utils.js');
const copts = require('../lib/createOptions.js');
const parse = require('../lib/parse.js');
const generate = require('../lib/generateSwagger.js');
const openapiv3 = require('../lib/openApiV3.js');
const validate = require('../lib/validate.js');
const extraXSD = require('../lib/extraXSD.js');
const R = require('../lib/report.js');

const q = require('q');
// var g = require('strong-globalize')();
const g = require('../lib/strong-globalize-fake.js');

/**
 * Create an openapi from wsdl
 * @param {Buffer or String file location or String url} wsdl or zip content
 * @param {String} serviceName name of the wsdl service
 * @param {String} wsdlId id to use in the generated swagger.  Often this is the filename
 * @param options
 *     type: 'wsdl' (default) or 'wsdl-to-rest'
 *     openapiVersion: '2.0' (default) or '3.0'
 *     wssecurity: true (default) or false
 *     gateway: datapower-gateway (default) or datapower-api-gateway or micro-gateway
 *     req: request or null (used for i18n negotiation and error collection)
 *     allowExtraFiles: false (default) or true
 *     level: messages to report: DETAIL, INFO (default), WARNING, ERROR
 *     analysis: perform analysis of created openapi (default false)
 *     defaults: object to merge into openapi after generation.  Same shape as openapi
 *     auth: auth object if wsdl is protected url
 *     badgerfishDefs: true (default) or false.  Json definitions in badgerfish form
 *     port: (optional) port name.  If not specified, first soap port is used.
 *     mapOptions: setting to use for autogenerated assembly map. The default is no map.options
 *         mapOptions.includeEmptyXMLElements
 *         mapOptions.namespaceInheritance
 *         mapOptions.inlineNamespaces
 *     mapSOAPFaults: true (if wsdl-to-rest) or false.  Catch block for SOAPFaults
 * @return {
 *              openapi: <openapi>
 *              analysis: {  analysis messages }
 *         }
 */
function createOpenApi(wsdl, serviceName, wsdlId, options) {
    let def = q.defer();
    try {
        let defaults = {
            mapSOAPFaults: options.type === 'wsdl-to-rest',
        };
        let createOptions = copts.create(options, defaults);
        let req = createOptions.req;

        R.start(req, 'createOpenApi');

        // Parse the wsdl
        parse.getJsonForWSDL(wsdl, createOptions.auth, createOptions).then(function(allWSDLs) {
            try {
                // If a configuration file was found, apply it to createOptions
                if (createOptions.config) {
                    _.merge(createOptions, createOptions.config);
                }

                // Get WSDL Services makes sure that the allWSDLs array is correct.
                // It also gathers some informational and error messages that are added to the req.context
                let serviceData = parse.getWSDLServicesAll(allWSDLs, createOptions);

                // Locate the wsld entry for the indicated service
                let wsdlEntry = parse.findWSDLForServiceName(allWSDLs, serviceName, null);

                // Create a 2.0 wsdl proxy or wsdl to rest open api
                let openapi = (createOptions.type === 'wsdl-to-rest') ?
                    generate.generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, createOptions) :
                    generate.generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, createOptions);

                let convertDef = q.defer();
                // Convert to 3.0 if necessary
                if (createOptions.openapiVersion === '2.0') {
                    convertDef.resolve(openapi);
                } else {
                    openapiv3.getOpenApiV3(openapi, createOptions).then(function(openapi) {
                        convertDef.resolve(openapi);
                    }, function(err) {
                        convertDef.reject(err);
                    });
                }
                // Add additional analysis if requested
                convertDef.promise.then(function(openapi) {
                    try {
                        let result = { openapi: openapi };

                        // Get the updated archive
                        if (allWSDLs && allWSDLs[0].archive) {
                            result.outArchive = allWSDLs[0].archive;
                        }
                        if (!createOptions.analysis) {
                            R.end(req, 'createOpenApi');
                            def.resolve(result);
                        } else {
                            validate.sniffSwagger(openapi, createOptions).then(function(analysis) {
                                // The analysis object messages from the Root (and target service)
                                // Get the new validation errors
                                result.analysis = analysis;
                                let analysisErrors = analysis.Root.error || [];
                                let openApiErrors = openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages.error || [];
                                let validationErrors = _.difference(analysisErrors, openApiErrors);

                                // Embed the errors into the openapi
                                _.merge(openapi['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages,
                                        analysis.Root);
                                if (openapi['x-ibm-configuration'].targets) {
                                    for (let target in openapi['x-ibm-configuration'].targets) {
                                        if (analysis[target]) {
                                            _.merge(openapi['x-ibm-configuration'].targets[target]['x-ibm-configuration']['x-ibm-apiconnect-wsdl'].messages,
                                                   analysis[target]);
                                        }
                                    }
                                }

                                // If validation errors, then fail
                                if (validationErrors.length > 0) {
                                    let err = new Error(JSON.stringify(analysis));
                                    R.end(req, 'createOpenApi', err);
                                    def.reject(u.convertToValidationErr(err));
                                } else {
                                    R.end(req, 'createOpenApi');
                                    def.resolve(result);
                                }
                            }, function(err) {
                                R.end(req, 'createOpenApi', err);
                                def.reject(u.convertToValidationErr(err));
                            });
                        }
                    } catch (err) {
                        R.end(req, 'createOpenApi', err);
                        def.reject(u.convertToValidationErr(err));
                    }
                }, function(err) {
                    R.end(req, 'createOpenApi', err);
                    def.reject(u.convertToValidationErr(err));
                });
            } catch (e) {
                R.end(req, 'createOpenApi', e);
                def.reject(u.convertToValidationErr(e));
            }
        }, function(err) {
            R.end(req, 'createOpenApi', err);
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addTargetOpenApi
* @param openApi - existing openApi
* @param wsdl - Buffer containing the wsdl/zip or location of the wsdl/zip
* @param wsdlServiceName - Service
* @param createOptions
*   wssecurity
*   port: (optional) port name.  If not specified, first soap port is used.
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
function addTargetOpenApi(openapi, wsdl, wsdlServiceName, options) {
    let _defaults = {
        openapiVersion: (openapi.openapi) ? '3.0' : '2.0',
    };
    let createOptions = copts.create(options, _defaults);
    let def = q.defer();
    try {
        createOpenApi(wsdl, wsdlServiceName, wsdlServiceName, createOptions).then(function(result) {
            try {
                // Update the references to point at the target definitions/schemas
                let tgtOpenApi = updateRefs(result.openapi, wsdlServiceName);

                openapi['x-ibm-configuration'].targets = openapi['x-ibm-configuration'].targets || {};
                openapi['x-ibm-configuration'].targets[wsdlServiceName] = tgtOpenApi;
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addXSDToTargetOpenApi
* @param openApi - existing openApi
* @param xsd - Buffer containing the xsd or location of the xsd
* @param wsdlServiceName - Service
* @param createOptions
*   req: request or null (used for i18n negotiation)
* @return promise openApi
*/
function addXSDToTargetOpenApi(openapi, xsd, wsdlServiceName, options) {
    let createOptions = copts.create(options);
    let def = q.defer();
    try {
        extraXSD.getDefinitionsForXSD(xsd, null, null, createOptions).then(function(definitions) {
            try {
                definitions = updateRefs(definitions, wsdlServiceName);
                // Find the definition section of the target schema
                let tgt = openapi['x-ibm-configuration'].targets[wsdlServiceName];
                if (openapi.openapi) {
                    tgt = tgt.components.schemas;
                } else {
                    tgt = tgt.definitions;
                }
                // Add the new definitions
                for (let definition in definitions) {
                    tgt[definition] = u.deepClone(definitions[definition]);
                }
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

function updateRefs(json, serviceName) {
    let jsonString = JSON.stringify(json);
    let src = '#/';
    let tgt = '#/x-ibm-configuration/targets/' + serviceName + '/';
    jsonString = jsonString.replace(new RegExp(src, 'g'), tgt);
    return JSON.parse(jsonString);
}

/**
* Validates wsdl and rejects with error containing messages.
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req and other options.
* @returns promise of serviceData
*/
function validateWSDL(locationOrContent, options) {
    options = copts.create(options);
    var def = q.defer();
    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    const opts = u.deepClone(options);
    opts.validate = true;
    opts.req = req;
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                // Extra validation of the wsdl definition
                let errs = [];
                for (let i = 0; i < allWsdls.length; i++) {
                    errs = errs.concat(parse.sanityCheckDefinition(allWsdls[i].json.definitions, req));
                }
                for (let i = 0; i < errs.length; i++) {
                    u.addValidationErr(valErr, errs[i], req);
                }
                // Get the list of services, ports, and bindings
                let serviceData = parse.getWSDLServicesAll(allWsdls, options);

                // Validate the serviceData
                if (!serviceData ||
                    !serviceData.bindings || serviceData.bindings.length == 0 ||
                    !serviceData.portTypes || serviceData.bindings.portTypes == 0) {
                    u.addValidationErr(valErr, g.http(u.r(req)).f('A wsdl \'definition\' was not found.'), req);
                } else if (!serviceData || !serviceData.services || serviceData.services.length == 0) {
                    u.addValidationErr(valErr, g.http(u.r(req)).f('No wsdl \'services\' were found.'), req);
                } else {
                    for (let service of serviceData.services) {
                        if (!service.portName) {
                            u.addValidationErr(valErr,
                               g.http(u.r(req)).f('The wsdl \'service\' %s does not contain a \'port\'.', service.service),
                               req);
                        }
                    }
                }
                if (valErr.messages && valErr.messages.length > 0) {
                    def.reject(valErr);
                } else {
                    // Get the updated archive
                    if (allWsdls && allWsdls[0].archive) {
                        serviceData.outArchive = allWsdls[0].archive;
                    }
                    def.resolve(serviceData);
                }
            } catch (e) {
                u.addValidationErr(valErr, e, req);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e, req);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e, req);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* Validates xsd and rejects with error containing messages.
* @param locationOrContent location of XSD or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth, req, and other options.
* @returns promise
*/
function validateXSD(locationOrContent, options) {
    options = copts.create(options, { strictValidation: true });

    var def = q.defer();
    let req = options.req;
    var valErr = g.http(u.r(req)).Error('Validation Error');
    let opts = u.deepClone(options);
    opts.validate = true;
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                parse.getWSDLServicesAll(allWsdls, options);
                def.resolve();
            } catch (e) {
                u.addValidationErr(valErr, e, req);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e, req);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e, req);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise of serviceData
*/
function introspectWSDL(locationOrContent, options) {
    // validateWSDL produces the serviceData along with an updated archive.
    // The updated archive is unnecessary when introspectWSDL is invoked.
    let serviceData = validateWSDL(locationOrContent, options);
    delete serviceData.outArchive;
    return serviceData;
}


exports.addTargetOpenApi = addTargetOpenApi;
exports.addXSDToTargetOpenApi = addXSDToTargetOpenApi;
exports.createOpenApi = createOpenApi;
exports.introspectWSDL = introspectWSDL;
exports.validateWSDL = validateWSDL;
exports.validateXSD = validateXSD;
