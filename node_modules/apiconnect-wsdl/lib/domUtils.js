/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2019
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';
var _ = require('lodash');
const u = require('../lib/utils.js');
const fileUtils = require('../lib/fileUtils.js');
const xmldom = require('xmldom');
const g = require('../lib/strong-globalize-fake.js');
const R = require('../lib/report.js');

/**
* @return information about the indicated namespace
*/
function getNamespaceInfo(namespace) {
    return NAMESPACE_INFO[namespace] || {
        known: false,
        base: false,
        extension: true,
        for: 'UNKNOWN'
    };
}

/**
* @return namespaces that we have seen before (i.e. spec namespaces)
*/
function getKnownNamespaces() {
    let known = [];
    for (let ns in NAMESPACE_INFO) {
        if (NAMESPACE_INFO[ns].known) {
            known.push(ns);
        }
    }
    return known;
}

/**
* @return info about this node ncName
*/
function getNameInfo(ncName) {
    if (_.indexOf(COMMOM_NODE_NAMES, ncName) >= 0) {
        return {
            known: true,
            common: true
        };
    } else if (UNCOMMON_NODE_NAMES[ncName]) {
        return {
            known: true,
            common: false,
            ns: UNCOMMON_NODE_NAMES[ncName]
        };
    } else {
        return {
            known: false,
            common: false,
            ns: 'unknown'
        };
    }
}

/**
* @return info about this attribute ncName
*/
function getAttrInfo(ncName) {
    if (_.indexOf(COMMOM_ATTR_NAMES, ncName) >= 0) {
        return {
            known: true,
            common: true
        };
    } else if (UNCOMMON_ATTR_NAMES[ncName]) {
        return {
            known: true,
            common: false,
            ns: UNCOMMON_ATTR_NAMES[ncName]
        };
    } else {
        return {
            known: false,
            common: false,
            ns: 'unknown'
        };
    }
}

/**
* @return load an xmldom from text
*/
function loadDOM(text) {
    let report = {
        warnings: [],
        errors: []
    };
    var dom = new xmldom.DOMParser({
        errorHandler: {
            warning: function(msg) {
                report.warnings.push(msg);
            },
            error: function(msg) {
                report.errors.push(msg);
            },
            fatalError: function(msg) {
                report.errors.push(msg);
            }
        } }).parseFromString(text, 'text/xml');
    if (report.errors.length > 0 || report.warnings.length > 0) {
        throw new Error(JSON.stringify(report));
    }
    return dom;
}

/**
* Traverse dom
* @param node (start with root)
* @param f callback for each node
* @param list ancestor schema and definitions
*/
function traverseDOM(node, f, list) {
    list = list || [];
    if (!node) {
        return;
    }
    let isRoot = !node.parentNode;
    // A null value returned from f indicates that the descendents
    // are not processed.
    if (f(node, list) && node.childNodes) {
        let isSchemaOrDef = (node.localName === 'schema' || node.localName === 'definitions');
        if (isSchemaOrDef) {
            list.push(node);
        }
        // Must create a copy of the childNodes prior to traversing
        // the children because a descendent call to f may delete a node.
        let childNodes = [];
        for (let i = 0; i < node.childNodes.length; i++) {
            childNodes.push(node.childNodes[i]);
        }
        for (let i = 0; i < childNodes.length; i++) {
            traverseDOM(childNodes[i], f, list);
        }
        if (isSchemaOrDef) {
            list.pop();
        }
    }
}

/**
* @return a list of locations referenced from this file (via include, import).  The locations are normalized.
*/
function getLocations(doc, fileName, req) {

    let currLocation = '';
    if (fileName) {
        let lastSlash = fileName.lastIndexOf('/');
        currLocation = lastSlash < 0 ? '' : fileName.substring(0, lastSlash);
    }
    let locations = [];
    let e = doc.getElementsByTagNameNS(SCHEMA_NS, 'include');
    for (let i = 0; i < e.length; i++) {
        let newLocation = e[i].getAttribute('schemaLocation');
        if (newLocation) {
            let location = fileUtils.normalizeLocation(newLocation, currLocation, true);
            if (locations.indexOf(location) < 0) {
                locations.push(location);
            }
        }
    }
    e = doc.getElementsByTagNameNS(SCHEMA_NS, 'import');
    for (let i = 0; i < e.length; i++) {
        let newLocation = e[i].getAttribute('schemaLocation');
        if (newLocation) {
            let location = fileUtils.normalizeLocation(newLocation, currLocation, true);
            if (locations.indexOf(location) < 0) {
                locations.push(location);
            }
        }
    }
    e = doc.getElementsByTagNameNS(SCHEMA_NS, 'redefine');
    for (let i = 0; i < e.length; i++) {
        let newLocation = e[i].getAttribute('schemaLocation');
        if (newLocation) {
            let location = fileUtils.normalizeLocation(newLocation, currLocation, true);
            if (locations.indexOf(location) < 0) {
                locations.push(location);
            }
        }
    }
    e = doc.getElementsByTagNameNS(WSDL_NS, 'import');
    for (let i = 0; i < e.length; i++) {
        let newLocation = e[i].getAttribute('location');
        if (newLocation) {
            let location = fileUtils.normalizeLocation(newLocation, currLocation, true);
            if (locations.indexOf(location) < 0) {
                locations.push(location);
            }
        } else {
            R.warning(req, g.http(u.r(req)).f('A wsdl import does not have a location attribute. This is a violation of a WS-I Rule (R2007 A DESCRIPTION MUST specify a non-empty location attribute on the wsdl:import element).  This problem was found in file %s.', fileName));
        }
    }
    return locations;
}


/**
* @param dom for XSD or WSDL
* @return map of names of nodes and attributes and namespaces declarations
*/
function getNamesMap(dom) {
    let map = { nodes: {}, attrs: {}, namespaces: {}, nsMap: {} };
    traverseDOM(dom, function(node) {
        if (node.nodeName) {
            let i = node.nodeName.indexOf(':');
            let name = i > -1 ? node.nodeName.substring(i + 1) : node.nodeName;
            map.nodes[name] = map.nodes[name] ? map.nodes[name]++ : 1;
        }
        if (node.attributes) {
            for (let i = 0; i < node.attributes.length; i++) {
                let attr = node.attributes[i].nodeName;

                if (attr.startsWith('xmlns:' || attr === 'xmlns')) {
                    let ns = node.attributes[i].nodeValue;
                    map.namespaces[ns] = map.namespaces[ns] ? map.namespaces[ns]++ : 1;
                    let prefix = attr === 'xmlns' ? '' : node.attributes[i].localName;
                    let value = map.nsMap[prefix] || [];
                    if (value.indexOf(ns) < 0) {
                        value.push(ns);
                        map.nsMap[prefix] = value;
                    }
                    continue;
                }
                let index = attr.indexOf(':');
                let name = index > -1 ? attr.substring(index + 1) : attr;
                map.attrs[name] = map.attrs[name] ? map.attrs[name]++ : 1;
            }
        }
        return node;
    });
    return map;
}

/**
* @return information about this nodetype
*/
function getNodeTypeInfo(nodetype) {
    return NODE_TYPE[nodetype] || { keep: true, report: true, name: 'UNKNOWN TYPE' + nodetype };
}

/**
* @return DOM with DTD and other bad nodes removed
*/
function removeDTD(dom) {
    traverseDOM(dom, function(node) {
        let info = getNodeTypeInfo(node.nodeType);
        if (info.keep) {
            return node;
        } else {
            node.parentNode.removeChild(node);
            return null;
        }
    });
}

const SCHEMA_NS = 'http://www.w3.org/2001/XMLSchema';
const WSDL_NS = 'http://schemas.xmlsoap.org/wsdl/';
const WSDL_SOAP11_NS = 'http://schemas.xmlsoap.org/wsdl/soap/';
const WSDL_SOAP12_NS = 'http://schemas.xmlsoap.org/wsdl/soap12/';
const WSDL_HTTP_NS = 'http://schemas.xmlsoap.org/wsdl/http/';
const WSDL_MIME_NS = 'http://schemas.xmlsoap.org/wsdl/mime/';
const WS_ADDRESSING_NS = 'http://www.w3.org/2006/05/addressing/wsdl';

/**
* Remove all non-WSDL and non-XSD elements.
* Removing elements helps ensure that the node soap and other processors don't fail or produce bad data.
*
* Add apicID to schema elements.
* The apicID element is used to determine order of the elements, and in addition
* it forces an attribute onto each element which ensures that the 'undefined' key is set.
*/
function pruneAndAddID(dom, fileName, req) {
    fileName = fileName === 'MEMORY' ? 'file' : fileName;
    let id = 0;
    let map = {
        [SCHEMA_NS]: true,
        [WSDL_NS]: true,
        [WSDL_HTTP_NS]: true,
        [WSDL_SOAP11_NS]: true,
        [WSDL_SOAP12_NS]: true,
        [WSDL_MIME_NS]: true,
        [WS_ADDRESSING_NS]: true,
    };
    traverseDOM(dom, function(node) {
        if (node.nodeType === 1) {
            let info = getNameInfo(node.localName);
            if (map[node.namespaceURI]) {
                if (!info.common) {
                    // Looks like an attempt to use a name that is not defined in the standard
                    throw g.http(u.r(req)).Error('The following name, %s, was bound to specification standard namespace %s in %s.  This is an unrecognized element, please correct.',
                    node.nodeName, fileName, node.namespaceURI);
                } else if (node.namespaceURI === SCHEMA_NS) {
                    if (node.localName !== 'documentation') {
                        node.setAttribute('apicID', id++);
                    }
                }
            } else {
                // Discard this element
                if (info.common) {
                    // If this is a common name, then someone may have mispelled a namespace.  Throw an error
                    throw g.http(u.r(req)).Error('The following name, %s, was bound to namespace %s in %s.  This is an unrecognized element, please correct.',
                    node.nodeName, fileName, node.namespaceURI);
                }
                node.parentNode.removeChild(node);
                node = null;
            }
        }
        return node;
    });
    return dom;
}


// Each namespace has the following information
//   known: indicates that we have seen this before and it is valid
//   base: means that it is an essential piece of XSD/WSDL
//   extension: means that it is an extension to wsdl or xsd that we actually process or checking (WS-SECURITY).
//              If known but not base/extension, this means that we recognize and ignore it.
//   for: text indicating how it is known.
const NAMESPACE_INFO = {
    'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd': {
        known: true,
        base: false,
        extension: true,
        for: 'WS-SECURITY'
    },
    'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd': {
        known: true,
        base: false,
        extension: true,
        for: 'WS-SECURITY'
    },
    'http://schemas.microsoft.com/ws/06/2004/mspolicy/netbinary1': {
        known: true,
        base: false,
        extension: false,
        for: 'Microsoft',
    },
    'http://schemas.microsoft.com/ws/06/2004/policy/http': {
        known: true,
        base: false,
        extension: false,
        for: 'Microsoft',
    },
    'http://schemas.microsoft.com/ws/2005/12/wsdl/contract': {
        known: true,
        base: false,
        extension: false,
        for: 'Microsoft',
    },
    'http://schemas.xmlsoap.org/ws/2004/09/policy': {
        known: true,
        base: false,
        extension: false,
        for: 'WS-Policy',
    },
    'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy': {
        known: true,
        base: false,
        extension: false,
        for: 'WS-Policy',
    },
    'http://schemas.xmlsoap.org/ws/2006/02/addressingidentity': {
        known: true,
        base: false,
        extension: false,
        for: 'WS-Addressing',
    },
    [WSDL_NS]: {
        known: true,
        base: true,
        extension: false,
        for: 'WSDL',
    },
    [WSDL_HTTP_NS]: {
        known: true,
        base: false,
        extension: true,  // This is for HTTP bindings in WSDL, which we currently ignore
        for: 'WSDL HTTP BINDING',
    },
    [WSDL_MIME_NS]: {
        known: true,
        base: false,
        extension: true,  // This is for MIME part scanning, we don't do anything special with mime
        for: 'WSDL MIME',
    },
    [WSDL_SOAP12_NS]: {
        known: true,
        base: true,
        extension: false,
        for: 'WSDL SOAP 1.2',
    },
    [WSDL_SOAP11_NS]: {
        known: true,
        base: true,
        extension: false,
        for: 'WSDL SOAP 1.1',
    },
    'http://ws-i.org/schemas/conformanceClaim/': {
        known: true,
        base: false,
        extension: true,  // Currently ignore this, but see https://github.ibm.com/velox/apiconnect-wsdl/issues/219
        for: 'WSDL WS-I',
    },
    'http://www.w3.org/2000/09/xmldsig#': {
        known: true,
        base: false,
        extension: false,
        for: 'WSDL WS-I',
    },
    [SCHEMA_NS]: {
        known: true,
        base: true,
        extension: false,
        for: 'XML Schema',
    },
    'http://www.w3.org/2005/05/xmlmime': {
        known: true,
        base: false,
        extension: true,  // This is for MIME part scanning, we don't do anything special with mime
        for: 'WSDL MIME',
    },
    'http://www.w3.org/2005/08/addressing': {
        known: true,
        base: false,
        extension: true,
        for: 'WS-Addressing',
    },
    [WS_ADDRESSING_NS]: {
        known: true,
        base: false,
        extension: true,
        for: 'WS-Addressing',
    },
    'http://www.w3.org/2007/XMLSchema-versioning': {
        known: true,
        base: false,
        extension: true,  // We currently only check and report if we find a versioning issue
        for: 'XML Schema 1.1',
    },
    'http://www.w3.org/XML/1998/namespace': {
        known: true,
        base: false,
        extension: true,
        for: 'XML Schema',
    },
    'http://java.sun.com/xml/ns/jaxws': {
        known: true,
        base: false,
        extension: false,
        for: 'JAXS GENERATION',
    },
    'http://schemas.xmlsoap.org/ws/2003/05/partner-link/': {
        known: true,
        base: false,
        extension: false,
        for: 'BPEL',
    },
    'http://www.w3.org/2001/12/soap-encoding': {
        known: true,
        base: false,
        extension: false,
        for: 'SOAP ENCODING'
    }
};

// Common NCNames for Nodes found in XSD or WSDL
var COMMOM_NODE_NAMES = [
    '#document', 'definitions', 'documentation', 'types', 'schema',
    'element', 'complexType', 'annotation', '#text', 'appinfo', 'sequence', 'message', 'part', 'portType',
    'operation', 'input', 'output', 'binding', 'body', 'service', 'port', 'address',
    '#comment', 'include', 'import', 'complexType', 'extension', 'restriction', 'simpleType',
    'simpleContent', 'complexContent', 'minLength', 'maxLength', 'pattern',
    'minInclusive', 'maxInclusive', 'attribute', 'group', 'attributeGroup',
    'totalDigits', 'enumeration', 'choice', '#cdata-section', 'any', 'anyAttribute',
    'list', 'fault', 'all', 'union', 'length', 'minInclusive', 'maxInclusive', 'minExclusive', 'maxExclusive', 'fractionDigits',
    'header', 'whiteSpace', 'urlEncoded', 'redefine', 'notation', 'unique', 'headerfault', 'mimeXml', 'content', 'multipartRelated',
    'selector', 'field',
    'UsingAddressing'
];

// Uncommon NCNames and the namspace they are usually associated with
var UNCOMMON_NODE_NAMES = {
    enableWrapperStyle: 'http://java.sun.com/xml/ns/jaxws',
    bindings: 'http://java.sun.com/xml/ns/jaxws',
    UsingPolicy: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    PolicyReference: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    Policy: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    ExactlyOne: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    All: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    TransportBinding: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    TransportToken: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    HttpsToken: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    AlgorithmSuite: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    Layout: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    Basic256: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    Strict: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    UsernameToken: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    SupportingTokens: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    WssUsernameToken10: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    EndpointReference: 'http://www.w3.org/2005/08/addressing',
    Address: 'http://www.w3.org/2005/08/addressing',
    Identity: 'http://schemas.xmlsoap.org/ws/2006/02/addressingidentity',
    Spn: 'http://schemas.xmlsoap.org/ws/2006/02/addressingidentity',
    NegotiateAuthentication: 'http://schemas.microsoft.com/ws/06/2004/policy/http',
    BbinaryAuthentication: 'http://schemas.microsoft.com/ws/06/2004/policy/http',
    BasicAuthentication: 'http://schemas.microsoft.com/ws/06/2004/policy/http',
    BinaryEncoding: 'http://schemas.microsoft.com/ws/06/2004/mspolicy/netbinary1',
    role: 'http://schemas.xmlsoap.org/ws/2003/05/partner-link/',
    partnerLinkType: 'http://schemas.xmlsoap.org/ws/2003/05/partner-link/',
};

// Common NCNames for attributes found in xsd and wsdl files
var COMMOM_ATTR_NAMES = [
    'name', 'targetNamespace', 'required', 'xmlns', 'type', 'lang', 'source',
    'minOccurs', 'maxOccurs', 'element', 'message', 'style', 'transport', 'soapAction',
    'use', 'binding', 'location', 'elementFormDefault', 'attributeFormDefault', 'mixed', 'ref',
    'base', 'value', 'fixed', 'default', 'version', 'schemaLocation', 'substitutionGroup',
    'namespace', 'nillable', 'id', 'abstract', 'processContents', 'final', 'itemType', 'Action',
    'memberTypes', 'parts', 'parameterOrder', 'part', 'blockDefault', 'encodingStyle', 'finalDefault', 'xpath', 'refer',
    'form', 'verb', 'expectedContentTypes', 'minVersion', 'maxVersion',
    'apicID' // This is an attribute silently added by APIC during processing so that we can track order
];

// Uncommon  Attribute NCNames and the namspace they are usually associated with
var UNCOMMON_ATTR_NAMES = {
    docRoot: 'an ibm tooling extension',
    Id: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    URI: 'http://schemas.xmlsoap.org/ws/2004/09/policy',
    RequireClientCertificate: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    IncludeToken: 'http://schemas.xmlsoap.org/ws/2005/07/securitypolicy',
    usingSession: 'http://schemas.microsoft.com/ws/2005/12/wsdl/contract',
    arrayType: 'http://www.w3.org/2001/12/soap-encoding', // Actually in 'http://schemas.xmlsoap.org/wsdl/' but used for soap encoding
};

// NODE TYPE INFORMATION
var NODE_TYPE = {
    1: { keep: true,   report: false, name: 'ELEMENT_NODE' },
    2: { keep: true,   report: false, name: 'ATTRIBUTE_NODE' },
    3: { keep: true,   report: false, name: 'TEXT_NODE' },
    4: { keep: true,   report: false, name: 'CDATA_SECTION_NODE' },
    5: { keep: false,  report: true,  name: 'ENTITY_REFERENCE_NODE' },
    6: { keep: false,  report: true,  name: 'ENTITY_NODE' },
    7: { keep: true,   report: false, name: 'PROCESSING_INSTRUCTION_NODE' },
    8: { keep: false,  report: false, name: 'COMMENT_NODE' },
    9: { keep: true,   report: false, name: 'DOCUMENT_NODE' },
    10: { keep: false, report: true,  name: 'DOCUMENT_TYPE_NODE' },
    11: { keep: true,  report: true,  name: 'DOCUMENT_FRAGMENT_NODE' },
    12: { keep: true,  report: true,  name: 'NOTATION_NODE' }
};


// wraps all documentation in CDATA sections - allows random XML content to
// exist in the doc so that the parser doesn't barf on it
function protectDocumentation(contents) {
    var ret = '';
    if (contents) {
        if (contents.toString) {
            contents = contents.toString();
        }

        // Find the raw references to documentation elements in the contents
        // and add them to the elementList
        var elementList = [];
        var regex = /documentation>/gi;
        var result;
        while ((result = regex.exec(contents))) {
            var idx = result.index - 1;
            var prepend = '';
            while (contents[idx] != '<' &&
             contents[idx] != '/') {
                prepend = contents[idx] + prepend;
                idx--;
            }
            var name = prepend + 'documentation';
            if (elementList.indexOf(name) < 0) {
                elementList.push(name);
            }
        }

        // For each elementList item, call protectDocSpecific which
        // will wrap the contents of those elements in CDATA
        var len = elementList.length;
        ret = contents;
        for (var i = 0; i < len; i++) {
            var elementName = elementList[i];
            ret = protectDocSpecific(ret, elementName);
        } // end for
    }
    return ret;
}

/**
* Wrap the indicated elementName in a CDATA
*/
function protectDocSpecific(contents, elementName) {
    var ret = '';
    var index = 0;
    var offset = 0;
    var len = contents.length;
    var elementStart = '<' + elementName + '>';
    var elementEnd = '</' + elementName + '>';
    var elementLen = elementStart.length;
    while (offset < len) {
        index = contents.indexOf(elementStart, offset);
        if (index == -1) {
            ret += contents.substring(offset);
            break;
        } else {
            ret += contents.substring(offset, index + elementLen);
            var endIndex = contents.indexOf(elementEnd, index + elementLen);
            var doc = contents.substring(index + elementLen, endIndex);
            // put doc in CDATA if not done already
            var trimmed = doc.trim();
            if (trimmed.indexOf('<![CDATA[') != -1) {
                // remove any nested CDATA and wrap with ours
                doc = trimmed.replace(/]]>/g, '');
                doc = doc.replace(/<!\[CDATA\[/g, '');
                doc = '<![CDATA[' + doc + ']]>';
                ret += doc;
            } else if (doc.indexOf('<') == -1 && doc.indexOf('>') == -1) {
                // If no element start or end token, then don't bother wrapping in CDATA
                ret += doc;
            } else {
                doc = '<![CDATA[' + doc + ']]>';
                ret += doc;
            }
            ret += elementEnd;
            offset = endIndex + elementLen + 1;
        }
    } // end for
    return ret;
}

// Each token (key) must have a parent in the list (value)
const PARENT = {
    // Schema parents
    '<xsd_schema>': [ 'document', '<wsdl_types>' ],
    '<xsd_include>': [ '<xsd_schema>' ],
    '<xsd_import>': [ '<xsd_schema>' ],
    '<xsd_redefine>': [ '<xsd_schema>' ],
    '<xsd_appinfo>': [ '<xsd_annotation>' ],
    '<xsd_documentation>': [ '<xsd_annotation>' ],
    '<xsd_simpleType>': [ '<xsd_schema>', '<xsd_redefine>', '<xsd_attribute>', '<xsd_element>', '<xsd_restriction>', '<xsd_union>', '<xsd_list>' ],
    '<xsd_complexType>': [ '<xsd_schema>', '<xsd_redefine>', '<xsd_element>' ],
    '<xsd_group>': [ '<xsd_schema>', '<xsd_redefine>', '<xsd_sequence>', '<xsd_choice>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_sequence>': [ '<xsd_group>', '<xsd_sequence>', '<xsd_choice>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_choice>': [ '<xsd_group>', '<xsd_sequence>', '<xsd_choice>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_all>': [ '<xsd_group>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_any>': [ '<xsd_choice>', '<xsd_sequence>' ],
    '<xsd_attributeGroup>': [ '<xsd_schema>', '<xsd_redefine>', '<xsd_attributeGroup>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_anyAttribute>': [ '<xsd_attributeGroup>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_attribute>': [ '<xsd_schema>', '<xsd_attributeGroup>', '<xsd_complexType>', '<xsd_restriction>', '<xsd_extension>' ],
    '<xsd_element>': [ '<xsd_schema>', '<xsd_group>', '<xsd_sequence>', '<xsd_choice>', '<xsd_all>' ],
    '<xsd_complexContent>': [ '<xsd_complexType>' ],
    '<xsd_simpleContent>': [ '<xsd_complexType>' ],
    '<xsd_extension>': [ '<xsd_simpleContent>', '<xsd_complexContent>' ],
    '<xsd_restriction>': [ '<xsd_simpleType>', '<xsd_simpleContent>', '<xsd_complexContent>' ],
    '<xsd_enumeration>': [ '<xsd_restriction>' ],
    '<xsd_fractionDigits>': [ '<xsd_restriction>' ],
    '<xsd_totalDigits>': [ '<xsd_restriction>' ],
    '<xsd_length>': [ '<xsd_restriction>' ],
    '<xsd_minInclusive>': [ '<xsd_restriction>' ],
    '<xsd_maxInclusive>': [ '<xsd_restriction>' ],
    '<xsd_minExclusive>': [ '<xsd_restriction>' ],
    '<xsd_maxExInclusive>': [ '<xsd_restriction>' ],
    '<xsd_minLength>': [ '<xsd_restriction>' ],
    '<xsd_maxLength>': [ '<xsd_restriction>' ],
    '<xsd_pattern>': [ '<xsd_restriction>' ],
    '<xsd_whiteSpace>': [ '<xsd_restriction>' ],
    '<xsd_field>': [ '<xsd_key>', '<xsd_keyref>', '<xsd_unique>' ],
    '<xsd_selector>': [ '<xsd_key>', '<xsd_keyref>', '<xsd_unique>' ],
    '<xsd_key>': [ '<xsd_element>' ],
    '<xsd_keyref>': [ '<xsd_element>' ],
    '<xsd_unique>': [ '<xsd_element>' ],
    '<xsd_list>': [ '<xsd_simpleType>' ],
    '<xsd_notation>': [ '<xsd_schema>' ],
    '<xsd_union>': [ '<xsd_simpleType>' ],

    // WSDL
    '<wsdl_definitions>': [ 'document' ],
    '<wsdl_import>': [ '<wsdl_definitions>' ],
    // '<wsdl_documentation>': [ all wsdl ],
    '<wsdl_types>': [ '<wsdl_definitions>' ],
    '<wsdl_message>': [ '<wsdl_definitions>' ],
    '<wsdl_part>': [ '<wsdl_message>' ],
    '<wsdl_portType>': [ '<wsdl_definitions>' ],
    '<wsdl_binding>': [ '<wsdl_definitions>' ],
    '<wsdl_service>': [ '<wsdl_definitions>' ],
    '<wsdl_port>': [ '<wsdl_service>' ],
    '<wsdl_operation>': [ '<wsdl_portType>', '<wsdl_binding>' ],
    '<wsdl_input>': [ '<wsdl_operation>' ],
    '<wsdl_output>': [ '<wsdl_operation>' ],
    '<wsdl_fault>': [ '<wsdl_operation>' ],

    // SOAP Extension
    '<soap_binding>': [ '<wsdl_binding>' ],
    '<soap_operation>': [ '<wsdl_operation>' ],
    '<soap_body>': [ '<wsdl_input>', '<wsdl_output>', '<mime_part>' ],
    '<soap_header>': [ '<wsdl_input>', '<wsdl_output>', '<wsdl_fault>', '<mime_part>' ],
    '<soap_headerfault>': [ '<soap_header>' ],
    '<soap_fault>': [ '<wsdl_fault>' ],
    '<soap_address>': [ '<wsdl_port>' ],

    // MIME extension
    // Specification is not clear on mime usage on fault , so I am choosing to accept it.
    '<mime_multipartRelated>': [ '<wsdl_input>', '<wsdl_output>', '<wsdl_fault>' ],
    '<mime_content>': [ '<mime_part>', '<wsdl_input>', '<wsdl_output>', '<wsdl_fault>' ],
    '<mime_mimeXml>': [ '<mime_part>', '<wsdl_input>', '<wsdl_output>', '<wsdl_fault>' ],
    '<mime_part>': [ '<mime_multipartRelated>' ],

};
// Each token (key) must child tokens described by the regexp (value)
const CHILDREN = {
    // Schema
    '<xsd_schema>': /^((<xsd_include>|<xsd_import>|<xsd_redefine>|<xsd_annotation>)*(<xsd_simpleType>|<xsd_complexType>|<xsd_group>|<xsd_attributeGroup>|<xsd_element>|<xsd_attribute>|<xsd_notation>|<xsd_annotation>)*)$/,
    '<xsd_include>': /^(<xsd_annotation>)?$/,
    '<xsd_import>': /^(<xsd_annotation>)?$/,
    '<xsd_redefine>': /^(<xsd_simpleType>|<xsd_complexType>|<xsd_group>|<xsd_attributeGroup>|<xsd_annotation>)*$/,
    '<xsd_annotation>': /^(<xsd_appinfo>|<xsd_documentation>)*$/,
    '<xsd_simpleType>': /^(<xsd_annotation>)?(<xsd_restriction>|<xsd_list>|<xsd_union>)$/,
    '<xsd_complexType>': /^(<xsd_annotation>)?(<xsd_simpleContent>|<xsd_complexContent>|(<xsd_sequence>|<xsd_group>|<xsd_all>|<xsd_choice>)?((<xsd_attribute>|<xsd_attributeGroup>)*(<xsd_anyAttribute>)?))$/,
    '<xsd_group>': /^(<xsd_annotation>)?(<xsd_all>|<xsd_choice>|<xsd_sequence>)?$/,
    '<xsd_sequence>': /^(<xsd_annotation>)?(<xsd_element>|<xsd_sequence>|<xsd_group>|<xsd_choice>|<xsd_any>)*$/,
    '<xsd_choice>': /^(<xsd_annotation>)?(<xsd_element>|<xsd_sequence>|<xsd_group>|<xsd_choice>|<xsd_any>)*$/,
    '<xsd_all>': /^(<xsd_annotation>)?(<xsd_element>)*$/,
    '<xsd_any>': /^(<xsd_annotation>)?$/,
    '<xsd_attributeGroup>': /^(<xsd_annotation>)?(<xsd_attributeGroup>|<xsd_attribute>)*(<xsd_anyAttribute>)?$/,
    '<xsd_anyAttribute>': /^(<xsd_annotation>)?$/,
    '<xsd_attribute>': /^(<xsd_annotation>)?(<xsd_simpleType>)?$/,
    '<xsd_element>': /^(<xsd_annotation>)?(<xsd_simpleType>|<xsd_complexType>)?(<xsd_unique>|<xsd_key>|<xsd_keyref>)*$/,
    '<xsd_complexContent>': /^(<xsd_annotation>)?(<xsd_extension>|<xsd_restriction>)$/,
    '<xsd_simpleContent>': /^(<xsd_annotation>)?(<xsd_extension>|<xsd_restriction>)$/,
    '<xsd_extension>': /^(<xsd_annotation>)?(<xsd_all>|<xsd_sequence>|<xsd_group>|<xsd_choice>)?(<xsd_attributeGroup>|<xsd_attribute>)*(<xsd_anyAttribute>)?$/,
    '<xsd_simpleContent><xsd_restriction>': /^(<xsd_annotation>)?(<xsd_simpleType>)?(<xsd_minExclusive>|<xsd_maxExclusive>|<xsd_minInclusive>|<xsd_maxInclusive>|<xsd_totalDigits>|<xsd_fractionDigits>|<xsd_length>|<xsd_minLength>|<xsd_maxLength>|<xsd_whiteSpace>|<xsd_enumeration>|<xsd_pattern>)*(<xsd_attributeGroup>|<xsd_attribute>)*(<xsd_anyAttribute>)?$/,
    '<xsd_simpleType><xsd_restriction>': /^(<xsd_annotation>)?(<xsd_simpleType>)?(<xsd_minExclusive>|<xsd_maxExclusive>|<xsd_minInclusive>|<xsd_maxInclusive>|<xsd_totalDigits>|<xsd_fractionDigits>|<xsd_length>|<xsd_minLength>|<xsd_maxLength>|<xsd_whiteSpace>|<xsd_enumeration>|<xsd_pattern>)*$/,
    '<xsd_complexContent><xsd_restriction>': /^(<xsd_annotation>)?(<xsd_all>|<xsd_sequence>|<xsd_group>|<xsd_choice>)?(<xsd_attributeGroup>|<xsd_attribute>)*(<xsd_anyAttribute>)?$/,
    '<xsd_enumeration>': /^(<xsd_annotation>)?$/,
    '<xsd_fractionDigits>': /^(<xsd_annotation>)?$/,
    '<xsd_totalDigits>': /^(<xsd_annotation>)?$/,
    '<xsd_length>': /^(<xsd_annotation>)?$/,
    '<xsd_minInclusive>': /^(<xsd_annotation>)?$/,
    '<xsd_maxInclusive>': /^(<xsd_annotation>)?$/,
    '<xsd_minExclusive>': /^(<xsd_annotation>)?$/,
    '<xsd_maxExInclusive>': /^(<xsd_annotation>)?$/,
    '<xsd_minLength>': /^(<xsd_annotation>)?$/,
    '<xsd_maxLength>': /^(<xsd_annotation>)?$/,
    '<xsd_pattern>': /^(<xsd_annotation>)?$/,
    '<xsd_whiteSpace>': /^(<xsd_annotation>)?$/,
    '<xsd_field>': /^(<xsd_annotation>)?$/,
    '<xsd_selector>': /^(<xsd_annotation>)?$/,
    '<xsd_key>': /^(<xsd_annotation>)?(<xsd_selector>(<xsd_field>)+)$/,
    '<xsd_keyref>': /^(<xsd_annotation>)?(<xsd_selector>(<xsd_field>)+)$/,
    '<xsd_list>': /^(<xsd_annotation>)?(<xsd_simpleType>)?$/,
    '<xsd_notation>': /^(<xsd_annotation>)?$/,
    '<xsd_union>': /^(<xsd_annotation>)?(<xsd_simpleType>)*$/,
    '<xsd_unique>': /^(<xsd_annotation>)?(<xsd_selector>(<xsd_field>)+)$/,

    // WSDL
    '<wsdl_definitions>': /^(<xsd_annotation>)?(<wsdl_documentation>)?(<wsdl_import>)*(<wsdl_documentation>)?(<wsdl_types>)?(<wsdl_message>|<wsdl_portType>|<wsdl_binding>|<wsdl_service>)*$/,
    '<wsdl_import>': /^(<xsd_annotation>)?$/,
    '<wsdl_types>': /^(<wsdl_documentation>)?(<xsd_schema>)*$/,
    '<wsdl_message>': /^(<wsdl_documentation>)?(<wsdl_part>)*$/,
    '<wsdl_part>': /^(<wsdl_documentation>)?$/,
    '<wsdl_portType>': /^(<wsdl_documentation>)?(<wsdl_operation>)*$/,
    '<wsdl_binding>': /^(<wsdl_documentation>)?(<soap_binding>)?(<wsdl_operation>)*$/,
    '<wsdl_service>': /^(<wsdl_documentation>)?(<wsdl_port>)*$/,
    '<wsdl_port>': /^(<wsdl_documentation>)?(<soap_address>)?$/,
    '<wsdl_operation>': /^(<wsdl_documentation>)?(<soap_operation>)?(<wsdl_input>)?(<wsdl_output>)?(<wsdl_fault>)*$/,
    // Allow wsdl soap header elements before or after wsdl soap body
    '<wsdl_input>': /^(<wsdl_documentation>)?(<mime_multipartRelated>|<mime_content>|<mime_mimeXml>|((<soap_header>)*(<soap_body>)?(<soap_header>)*))$/,
    '<wsdl_output>': /^(<wsdl_documentation>)?(<mime_multipartRelated>|<mime_content>|<mime_mimeXml>|((<soap_header>)*(<soap_body>)?(<soap_header>)*))$/,

    // Allow soap_header on wsdl_fault...this is a hole in the spec
    // Specification is unclear about mime on wsdl_fault, so choosing to accept it.
    '<wsdl_fault>': /^(<wsdl_documentation>)?(<mime_multipartRelated>|<mime_content>|<mime_mimeXml>|((<soap_header>)*(<soap_fault>)?(<soap_header>)*))$/,

    // SOAP Extension
    '<soap_binding>': /^$/,
    '<soap_operation>': /^$/,
    '<soap_body>': /^$/,
    '<soap_header>': /^(<soap_headerfault>)*$/,
    '<soap_headerfault>': /^$/,
    '<soap_fault>': /^$/,
    '<soap_address>': /^$/,

    // MIME Extension
    '<mime_part>': /^(<wsdl_documentation>)?(<mime_multipartRelated>|<mime_content>|<mime_mimeXml>|((<soap_header>)*(<soap_body>)?(<soap_header>)*))$/,
    '<mime_multipartRelated>': /^(<mime_part>)*$/,
    '<mime_content>': /^$/,
    '<mime_mimeXml>': /^$/,
};

// Poorly ordered or duplicate annotation is ignored.
// Set the fields to false to enable stricter validation
const LAX = {
    '<wsdl_documentation>': true,
    '<xsd_annotation>': true,
    '<xsd_appinfo>': true,
    '<xsd_documentation>': true,
};

/**
* Check the dom for valid wsdl, xsd, soap extensions and mime extensions.
* This is done to prevent garbage from leaking to the backend.
* Garbage files can cause abends leading to denail of service.
* Garbage files can also set a precedent for API Connect supporting invalid files.
* @TODO The checker could be improved to process attributes too.
**/
function syntaxCheck(dom, fileName, req) {
    traverseDOM(dom, function(node) {
        let token = getToken(node);
        const parents = PARENT[token];
        if (parents) {
            let parentToken = getToken(node.parentNode);
            if (parents.indexOf(parentToken) < 0) {
                let msg = g.http(u.r(req)).f('Expected %s %s to have parent of %s but found %s. This invalid syntax was found in file %s.', token, getTokenName(node), parents, parentToken, fileName);
                // Mime syntax is a bit loose, so embed an error versus throwing a fatal error
                if (msg.indexOf('mime') > 0) {
                    R.error(req, msg);
                }  else {
                    throw new Error(msg);
                }
            }
            let regexp = CHILDREN[token] || CHILDREN[parentToken + token];
            let childTokens;
            if (regexp) {
                childTokens = getChildTokens(node);
                if (!regexp.test(childTokens)) {
                    let msg = g.http(u.r(req)).f('Expected %s %s to have children %s but found %s. This invalid syntax was found in file %s.', token, getTokenName(node), regexp, childTokens, fileName);
                    // Mime syntax is a bit loose, so embed an error versus throwing a fatal error
                    if (msg.indexOf('mime') > 0) {
                        R.error(req, msg);
                    }  else {
                        throw new Error(msg);
                    }
                }
            }
            if (token === '<xsd_restriction>') {
                let facets = [ 'length', 'pattern', 'totalDigits', 'fractionDigits', 'whiteSpace',
                    'minLength', 'maxLength', 'minInclusive', 'maxInclusive', 'minExclusive', 'maxExclusive' ];

                for (let i = 0; i < facets.length; i++) {
                    let r = new RegExp('/' + facets[i] + '/g');
                    let count = (childTokens.match(r) || []).length;
                    if (count > 1) {
                        let msg = g.http(u.r(req)).f('Found %s occurrences of facet %s. This invalid syntax was found in file %s.', count,  facets[i], fileName);
                        throw new Error(msg);
                    }
                }
            }
        }
        return node;
    });
}

/**
* Create a string 'token' representing this dom element.
* The token is used by the regexp code in syntaxChecker to verify wsdl, xsd, soap, mime
**/
function getToken(node) {
    let token = '';
    if (!node) {
        return token;
    }
    if (node.nodeType == 9) {
        token = 'document';
    } else if (node.nodeType == 1) {
        if (node.namespaceURI === SCHEMA_NS) {
            token = '<xsd_' + node.localName + '>';
        } else if (node.namespaceURI === WSDL_NS) {
            token = '<wsdl_' + node.localName + '>';
        } else if (node.namespaceURI === WSDL_SOAP11_NS || node.namespaceURI === WSDL_SOAP12_NS) {
            token = '<soap_' + node.localName + '>';
        } else if (node.namespaceURI === WSDL_MIME_NS) {
            token = '<mime_' + node.localName + '>';
        }
        if (LAX[token]) {
            token = '';
        }
    } else if (node.nodeType == 3) {
        let data = node.data.trim();
        if (data) {
            token = 'TEXT(' + data + ')';
        }
    }
    return token;
}

function getTokenName(node) {
    if (!node) {
        return '';
    }
    return node.getAttribute('name') || node.getAttribute('targetNamespace') || node.getAttribute('namespace') || node.getAttribute('ref');
}

/**
* Create a string 'token' representing this node's children
* The token is used by the regexp code in syntaxChecker to verify wsdl, xsd, soap, mime
**/
function getChildTokens(node) {
    let str = '';
    for (let i = 0; i < node.childNodes.length; i++) {
        str += getToken(node.childNodes[i]);
    }
    return str;
}

exports.loadDOM = loadDOM;
exports.getAttrInfo = getAttrInfo;
exports.getLocations = getLocations;
exports.getNamespaceInfo = getNamespaceInfo;
exports.getNamesMap = getNamesMap;
exports.getNameInfo = getNameInfo;
exports.getNodeTypeInfo = getNodeTypeInfo;
exports.getKnownNamespaces = getKnownNamespaces;
exports.protectDocumentation = protectDocumentation;
exports.pruneAndAddID = pruneAndAddID;
exports.removeDTD = removeDTD;
exports.syntaxCheck = syntaxCheck;
exports.traverseDOM = traverseDOM;
