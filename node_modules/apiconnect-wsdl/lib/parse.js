/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2019
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const d = require('../lib/domUtils.js');
var _ = require('lodash');
const parseUtils = require('../lib/parseUtils.js');
const fileUtils = require('../lib/fileUtils.js');
const postParse = require('../lib/postParse.js');
const flattener = require('../lib/flatten.js');
const jsyaml = require('js-yaml');
const assert = require('assert');
const XML2JSparseString = require('xml2js').parseString;


const q = require('q');
const yauzl = require('yauzl');
// var g = require('strong-globalize')();
const g = require('../lib/strong-globalize-fake.js');
const R = require('../lib/report.js');


/**
* Main entry point for accessing the files and returning the
* parsed content (allWSDLs).
* @param location of wsdl/zip files/urls
* If array item is a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param auth
* @param options
*   req: request or null (used for i18n negotiation)
*   flatten: dev only
*   allowExtraFiles: default true (legacy behavior)
* @return allWSDLs, which is a array of wsdlEntry object representing
* the parsed information.
*/
function getJsonForWSDL(location, auth, options) {
    var def = q.defer();
    var promiseList = [];
    var flatten = false;
    var outArchive;
    if (options) {
        flatten = options.flatten;
    } else {
        // Allow extra files in zip files...this is the legacy behavior
        options = {
            allowExtraFiles: true
        };
    }
    let req = options.req;
    R.start(req, 'getJsonForWSDL');
    R.start(req, 'parse');
    parse(location, auth, options).then(out => {
        outArchive = out.archive;
        // check for internal errors
        for (let i = 0; i < out.files.length; i++) {
            let file = out.files[i];
            if (file.doc && file.doc.internalError) {
                // If an internal is caught during parsing, throw it now.
                if (file.doc.internalError.message) {
                    file.doc.internalError.message = g.http(u.r(req)).f('The wsdl file is incorrect (%s).', file.doc.internalError.message);
                }
                R.end(req, 'parse', file.doc.internalError);
                def.reject(file.doc.internalError);
                return;
            }
        }
        R.end(req, 'parse');
        R.start(req, 'merge');
        // Now post process the files and return the allWSDLs array
        var checkDef = postParse.merge(out.files, auth, options);
        checkDef.then(function(allWSDLs) {
            // Flattening takes extra resources, so you need to request it.
            if (flatten) {
                flattener.flatten(out.files, allWSDLs);
            }
            R.end(req, 'merge');
            R.end(req, 'getJsonForWSDL');

            // Place the output archive in the first allWSDLs file item.
            if (allWSDLs && allWSDLs.length > 0) {
                allWSDLs[0].archive = outArchive;
            }
            def.resolve(allWSDLs);
        }, function(e) {
            R.end(req, 'merge', e);
            def.reject(e);
        });
    }).catch(reason => {
        R.end(req, 'parse', reason);
        def.reject(reason);
    });
    return def.promise;
}

/**
* Do some simple checking of the wsdl definition object and return an array of the problems found
*/
function sanityCheckDefinition(definitions, req) {
    let errs = [];
    // Make sure each portType.operation references a defined message
    let portTypes = u.makeSureItsAnArray(definitions.portType);
    let messages = u.makeSureItsAnArray(definitions.message);
    let bindings = u.makeSureItsAnArray(definitions.binding);
    let services = u.makeSureItsAnArray(definitions.service);


    // Make sure each operation references a message
    for (let i = 0; i < portTypes.length; i++) {
        let portType = portTypes[i];
        let operations = u.makeSureItsAnArray(portType.operation);
        for (let j = 0; j < operations.length; j++) {
            let operation = operations[j];
            let opName = operation['undefined'].name;
            let children = [ 'input', 'output', 'fault' ];
            for (let c = 0; c < children.length; c++) {
                let key = children[c];
                if (operation[key] && operation[key]['undefined'] && operation[key]['undefined'].message) {
                    let message = u.stripNamespace(operation[key]['undefined'].message);
                    let found = false;
                    for (let m = 0; m < messages.length  && !found; m++) {
                        if (messages[m]['undefined'] && messages[m]['undefined']) {
                            if (messages[m]['undefined'].name === message) {
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        errs.push(g.http(u.r(req)).f('Could not find wsdl \'message\' "%s" referenced in wsdl \'operation\' "%s". This is a violation of a WS-I Rule (R2101 A DESCRIPTION MUST NOT use QName references to WSDL components in namespaces that have been neither imported, nor defined in the referring WSDL document).', message, opName));
                    }
                }
            }
        }
    }
    // Make sure every binding operation has a matching portType operation
    for (let i = 0; i < bindings.length; i++) {
        let binding = bindings[i];
        let bindingName = binding['undefined'].name;
        let bOperations = u.makeSureItsAnArray(binding.operation);
        let portTypeName = u.stripNamespace(binding['undefined'].type);
        let portTypeFound = false;
        for (let j = 0; j < portTypes.length; j++) {
            let portType = portTypes[j];
            if (portType['undefined'].name === portTypeName) {
                portTypeFound = true;
                let pOperations = u.makeSureItsAnArray(portType.operation);
                if (pOperations.length !== bOperations.length) {
                    errs.push(g.http(u.r(req)).f('The number of wsdl \'operations\' in \'binding\' "%s" does not match the number of \'operations\' in its \'portType\' "%s".' +
                    ' This is a violation of a WS-I rule (R2718 A wsdl:binding in a DESCRIPTION MUST have the same set of wsdl:operations as the wsdl:portType to which it refers).',
                      bindingName, portTypeName));
                }
                for (let k = 0; k < bOperations.length; k++) {
                    let bOpName = bOperations[k]['undefined'].name;
                    let found = false;
                    for (let l = 0; l < pOperations.length && !found; l++) {
                        let pOpName = pOperations[l]['undefined'].name;
                        if (pOpName === bOpName) {
                            found = true;
                        }
                    }
                    if (!found) {
                        errs.push(g.http(u.r(req)).f('The wsdl \'operation\' "%s" in \'binding\' "%s" does not match any \'operations\' in its \'portType\' "%s".' +
                        ' This is a violation of a WS-I rule (R2718 A wsdl:binding in a DESCRIPTION MUST have the same set of wsdl:operations as the wsdl:portType to which it refers).',
                        bOpName, bindingName, portTypeName));
                    }
                }
            }
        }
        if (!portTypeFound) {
            errs.push(g.http(u.r(req)).f('The portType %s is not found. This is a violation of a WS-I Rule (R2101 A DESCRIPTION MUST NOT use QName references to WSDL components in namespaces that have been neither imported, nor defined in the referring WSDL document).', portTypeName));
        }
    }
    // Make sure the services have bindings
    for (let i = 0; i < services.length; i++) {
        let service = services[i];
        let serviceName = service['undefined'].name;
        let ports = u.makeSureItsAnArray(service.port);
        for (let j = 0; j < ports.length; j++) {
            let port = ports[j];
            let portName = port['undefined'].name;
            let bindingName = u.stripNamespace(port['undefined'].binding);
            let found = false;
            for (let k = 0; k < bindings.length && !found; k++) {
                let binding = bindings[k];
                if (binding['undefined'].name === bindingName) {
                    found = true;
                }
            }
            if (!found) {
                errs.push(g.http(u.r(req)).f('The wsdl \'binding\' "%s" referenced by \'service\' "%s" cannot be found.',
                  bindingName, serviceName));
            }
        }
    }
    return errs;
}


/**
* Get the services from allWSDLs.  Called by 508x
* @param allWSDLs (from getJsonForWSDL)
* @param options
*   req: request or null (used for i18n negotiation)
* @returns data object that contains the names of the services, portTypes, bindings, serviceOperations
*/
function getWSDLServices(allWSDLs, options) {
    let serviceData = getWSDLServicesAll(allWSDLs, options);
    // Remove portName and other fields not needed by 508x
    if (serviceData.services) {
        for (let i = 0; i < serviceData.services.length; i++) {
            delete serviceData.services[i].portName;
            delete serviceData.services[i].bindingName;
            delete serviceData.services[i].endpoint;
            delete serviceData.services[i].ports;
        }
    }
    return serviceData;
}

/**
* Get the services from allWSDLs.  Primarily used by the UI to display the services found
* in the parsed information (allWSDLs) so that the user can choose which service to generate.
* @param allWSDLs (from getJsonForWSDL)
* @param options
*   req: request or null (used for i18n negotiation)
* @returns data object that contains the names of the services, portTypes, bindings, serviceOperations
*/
function getWSDLServicesAll(allWSDLs, options) {
    options = options || {};
    let req = options.req;
    var data = {
        portTypes: {},
        bindings: {},
        services: []
    };
    try {
        var wLen = allWSDLs.length;
        var operations, operation, ops;
        var serviceMap = {};
        for (var x = 0; x < wLen; x++) {
            var wsdlJson = allWSDLs[x].json;
            var portTypes = u.makeSureItsAnArray(wsdlJson.definitions.portType);
            var typeLen = portTypes.length;
            for (var i = 0; i < typeLen; i++) {
                let portType = portTypes[i];
                operations = u.makeSureItsAnArray(portType.operation);
                ops = [];
                let len = operations.length;
                let opNames = {};
                for (var p = 0; p < len; p++) {
                    operation = operations[p];
                    let opName = operation['undefined'].name;
                    ops.push({
                        name: opName,
                        description: u.cleanupDocumentation(operation.documentation, req)
                    });
                    if (opNames[opName]) {
                        R.error(req, g.http(u.r(req)).f(
                          'Found multiple operations of the same name %s within portType %s.' +
                          ' This is a violation of a WS-I Rule (R2304 A wsdl:portType in a DESCRIPTION MUST have operations with distinct values for their name attributes).' +
                          ' Processing continues, but problems could occur.',
                          opName, portType.name));
                    }
                    opNames[opName] = operation;
                } // end for
                data.portTypes[portType['undefined'].name] = ops;
            } // end for
            var bindings = u.makeSureItsAnArray(wsdlJson.definitions.binding);
            var binLen = bindings.length;
            for (var j = 0; j < binLen; j++) {
                var binding = bindings[j];
                if (!binding || !binding.binding) {
                    continue;
                }
                let style = binding.binding['undefined'].style;
                var bindingType = binding['undefined'].type;
                bindingType = u.stripNamespace(bindingType);
                operations = u.makeSureItsAnArray(binding.operation);
                ops = [];
                var operLen = operations.length;
                for (var n = 0; n < operLen; n++) {
                    operation = operations[n];
                    ops.push(operation['undefined'].name);
                    let opStyle = operation.operation && operation.operation['undefined'] ? operation.operation['undefined'].style : '';
                    if (!style && opStyle) {
                        // If the style is not set on the binding, but is present on an operation then set the style
                        style = opStyle;
                    } else if (opStyle && (style !== opStyle)) {
                        // Found a mixture of operations, which is a violation
                        R.error(req, g.http(u.r(req)).f(
                         'SOAP Binding %s has a mixture of styles (%s and %s).' +
                         ' This is a violation of a WS-I Rule (R2705 A wsdl:binding in a DESCRIPTION MUST either be a rpc-literal binding or a document-literal binding).' +
                         ' Processing continues, but problems could occur.',
                         binding['undefined'].name, opStyle, style));
                    }
                } // end for
                var bind = {
                    type: bindingType,
                    operations: ops
                };
                // Only store soap bindings
                if (binding.binding && binding.binding['undefined'] &&
                   (binding.binding['undefined'].transport ||
                    binding.binding['undefined'].style == 'document' ||
                    binding.binding['undefined'].style == 'rpc')) {
                    data.bindings[binding['undefined'].name] = bind;
                    // Additional checking of the binding
                    if (binding.binding['undefined'].transport !== 'http://schemas.xmlsoap.org/soap/http') {
                        R.warning(req, g.http(u.r(req)).f(
                         'SOAP Binding %s has an invalid transport value (%s).' +
                         ' This is a violation of a WS-I Rule (R2702 When HTTP is used, a wsdl:binding element in a DESCRIPTION MUST specify the HTTP transport protocol with SOAP binding. Specifically, the transport attribute of its wsoap11:binding child MUST have the value "http://schemas.xmlsoap.org/soap/http").' +
                         ' Processing continues, but problems could occur.',
                         binding['undefined'].name, binding.binding['undefined'].transport));
                    }
                }
            } // end for
            var services = u.makeSureItsAnArray(wsdlJson.definitions.service);
            var servLen = services.length;
            for (var k = 0; k < servLen; k++) {
                var service = services[k];
                var ports = u.makeSureItsAnArray(service.port);
                ports = onlySoapPorts(ports, data.bindings);
                service.port = ports;
                var portLen = ports.length;
                if (ports.length == 0) {
                    continue;
                }

                let serv = {
                    service: service['undefined'].name,
                    filename: allWSDLs[x].filename,
                };
                if (service.documentation) {
                    serv.description = u.cleanupDocumentation(service.documentation, req);
                }

                // Process the ports
                for (let l = 0; l < portLen; l++) {
                    let port = ports[l];
                    let portName = port['undefined'].name;
                    let obj;
                    if (l == 0) {
                        // This is the default port, and is set at the top level
                        serv.portName = portName;
                        obj = serv;
                    } else {
                        // Other ports are put in the port map
                        serv.ports = serv.ports || {};
                        serv.ports[portName] = {};
                        obj = serv.ports[portName];
                    }
                    obj.bindingName = u.stripNamespace(port['undefined'].binding);
                    let endpoint = '';
                    if (portLen > 0) {
                        if (ports[0].address &&
                            ports[0].address['undefined']) {
                            endpoint = ports[0].address['undefined'].location;
                        }
                    }
                    obj.endpoint = endpoint;
                    let type = data.bindings[obj.bindingName] ? data.bindings[obj.bindingName].type : null;
                    obj.operations = [];
                    if (type) {
                        let ops = data.portTypes[type];
                        if (ops) {
                            for (let m = 0; m < ops.length; m++) {
                                let opObj = {
                                    operation: ops[m].name
                                };
                                if (ops[m].description) {
                                    opObj.description = ops[m].description;
                                }
                                obj.operations.push(opObj);
                            }
                        } else {
                            R.error(req, g.http(u.r(req)).f('The portType %s is not found. This is a violation of a WS-I Rule (R2101 A DESCRIPTION MUST NOT use QName references to WSDL components in namespaces that have been neither imported, nor defined in the referring WSDL document).', type));
                        }
                    }
                }

                // Add service if there are actual serviceChildren
                // and the service in this first time that the service for this
                // file is encountered.
                // (The tns is checked because a service will occur multiple times in
                // allWSDLs for circular wsdl imports, so we use the tns to ensure that only
                // one of these is used).
                if (allWSDLs[x].serviceChildren && allWSDLs[x].serviceChildren != {}) {
                    if (!serviceMap[serv.service]) {
                        serviceMap[serv.service] = [];
                    }
                    var found = false;
                    for (var ss = 0; !found && ss < serviceMap[serv.service].length; ss++) {
                        let s = serviceMap[serv.service][ss];
                        if (s.fullName === allWSDLs[x].fullName ||
                            s.endpoint === serv.endpoint) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        serviceMap[serv.service].push(
                          {
                              serv: serv,
                              fullName: allWSDLs[x].fullName,
                              endpoint: serv.endpoint
                          });
                        data.services.push(serv);
                    }
                }
            } // end for
        } // end for

        // Find duplicates and disambiguate the names
        // <serviceName>-from-<slugifyfullname>
        for (var s in serviceMap) {
            if (serviceMap[s].length > 1) {
                for (var z = 0; z < serviceMap[s].length; z++) {
                    serviceMap[s][z].serv.service += '-from-' + u.slugifyName(serviceMap[s][z].fullName);
                }
            }
        }
        return u.checkAndFix(data);
    } catch (error) {
        console.log(g.http(u.r(req)).f('Ignore error that occurred while parsing wsdl.'));
        console.log(error);
        R.error(req, 'Internal Error: ' + error);
        return u.checkAndFix(data);
    }
}

/**
* @param ports is service.ports
* @param bindings is object containing keys that are soap bindings
* @return port array with just soap ports
*/
function onlySoapPorts(ports, bindings) {
    let ret = [];
    let portLen = ports.length;
    for (var i = 0; i < portLen; i++) {
        if (ports[i].address  && ports[i]['undefined']  && ports[i]['undefined'].binding) {
            let bindingName = u.stripNamespace(ports[i]['undefined'].binding);
            if (bindings[bindingName]) {
                ret.push(ports[i]);
            }
        }
    }
    return ret;
}

/**
* @param allWSDLs (from getJsonForWSDL)
* @param serviceName (wsdl service name)
* @param servieFileName (used as a differentiator if multiple services with the same name)
* @returns WSDLEntry object for the indicated service.
*/
function findWSDLForServiceName(allWSDLs, serviceName, serviceFilename) {
    var ret = null;
    var len = allWSDLs.length;
    // If multiple services of the same name were detected,
    // then the serviceName was changed to disambiguate the services
    // <serviceName>-from-<slugifiedpath>
    var slugifyServiceFullName;
    var mangleIndex = serviceName.indexOf('-from-');
    if (mangleIndex > 0) {
        slugifyServiceFullName = serviceName.substring(mangleIndex + 6);
        serviceName = serviceName.substring(0, mangleIndex);
        serviceFilename = null;
    }
    for (var i = 0; i < len; i++) {
        var wsdlEntry = allWSDLs[i];
        if (wsdlEntry.serviceChildren && wsdlEntry.serviceChildren[serviceName]) {
            if (slugifyServiceFullName && wsdlEntry.fullName) {
                if (slugifyServiceFullName == u.slugifyName(wsdlEntry.fullName)) {
                    ret = wsdlEntry;
                    break;
                }
            } else if (serviceFilename && wsdlEntry.filename) {
                if (serviceFilename == wsdlEntry.filename) {
                    ret = wsdlEntry;
                    break;
                }
            } else {
                ret = wsdlEntry;
                break;
            }
        }
    } // end for
    return ret;
}

/**
 * Get allWSDLS from a single wsdl file (or zip)
 * @return promise { files: [], archive: new archive}
 */
function parse(filename, auth, options) {
    let opts = options || {};
    let req = opts.req;
    var totalProcessed = 0;
    var reject = false;  // Necessary to help halt distributed process of zip entries
    var def = q.defer();
    var files = [];
    try {
        // Get the rawContent of the files
        var fetchDef = fileUtils.asContent(filename, filename, auth, null, req);
        fetchDef.then(function(out) {
            try {
                var rawContent = out.content;
                let isZip = fileUtils.isZip(out.content);
                // Create an 'archive' of all of the files that will be needed.
                // In most cases, this archive will be a 'ZIP' archive, but in legacy mode it is a list of files.
                let isLegacy = out.fileName && !options.selfContained;
                let content;
                let fileName = null;
                if (isLegacy) {
                    content = fileUtils.encode(out.content, out.encoding);  // encode the contents
                    fileName = filename;  // Use the full path
                } else {
                    if (out.fileName) {
                        let words = out.fileName.split('/');
                        fileName = words[words.length - 1];
                    }
                }

                fileUtils.asArchive(out.content, req, fileName, isLegacy).then(function(archive) {
                    parsePass1(archive, options).then(function(fileSet) {
                        parsePass2(archive, fileSet, options).then(function(out) {
                            // Only return an output archive if the input is an archive
                            if (!isZip) {
                                delete out.archive;
                            }
                            def.resolve(out);
                        }, function(err) {
                            def.reject(err);
                        });
                    }, function(err) {
                        def.reject(err);
                    });
                }, function(err) {
                    def.reject(err);
                });
            } catch (e) {
                def.reject(e);
            }
        }, function(fileErr) {
            def.reject(fileErr);
        });
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}

function parsePass1(archive, options, fileSet) {
    let isExecutable = false;
    let req = options.req;
    let map = {};
    let def = q.defer();
    fileSet = fileSet || { };
    R.start(req, 'parsePass1');

    fileUtils.pipeArchive(archive, req,

    function(fileName, mode, req) {
        // Return true to ignore the file (silently)
        // Throw an error if invalid file.
        isExecutable = fileUtils.isExecutable(mode);
        if (fileUtils.isSymbolicLink(mode)) {
            throw g.http(u.r(req)).Error('A file for a symbolic link was encountered in the zip.  Remove the file %s.', fileName);
        }
        if (fileUtils.isMACOSX(fileName) || fileUtils.isDirectory(fileName)) {
            return true; // silently ignore
        }
        if (fileUtils.isWSDL(fileName) || fileUtils.isConfig(fileName)) {
            return false;
        }
        if (fileUtils.isXSD(fileName) || fileUtils.isXML(fileName)) {
            return fileSet[fileName] !== 'missing';  // Ignore files that are not in the calculated fileSet.
        }

        if (!options.allowExtraFiles) {
            throw g.http(u.r(req)).Error('Only .xsd and .wsdl files are allowed in the zip.  Remove the file %s.', fileName);
        }
        return true;

    },

    function(fileName, content, req) {
        // Process the decoded content of the file.
        let ret = {
            fileName: fileName,
            fileContent: null, // Set only if content should be changed in the output archive
        };
        if (fileUtils.isConfig(fileName)) {
            let opts = jsyaml.safeLoad(content, 'utf8');
            options.config = opts;
            return null;  // Don't put the config in the output archive
        }

        try {
            // Do a fast parse to ensure quality
            new XML2JSparseString(content, function(err, result) {
                if (err) {
                    throw err;
                }
            });
            // For the first pass, just calculate the referenced schema locations
            let dom = d.loadDOM(content);
            map[fileName] = d.getLocations(dom, fileName, req);
        }  catch (e) {
            // For legacy reasons, xml errors are only reported if the file is included/imported.
            // So ignore errors during the first pass.
            if (fileUtils.isXML(fileName)) {
                map[fileName] = [];
            } else {
                throw e;
            }
        }
        return ret;
    }).then(function(out) {
        // Collect any localized errors from the file processing, and reject if any found
        let messages = [];
        for (let i = 0; i < out.files.length; i++) {
            if (out.files[i].error) {
                messages.push(out.files[i].fileName + ': ' + out.files[i].error.message);
            }
        }
        if (messages.length > 0) {
            def.reject(new Error(messages.join('\n')));
        } else {
            let existingFiles = Object.keys(fileSet);
            let allFiles = u.deepClone(existingFiles);
            for (let key in map) {
                fileSet[key] = map[key];
                allFiles = _.union(allFiles, map[key]);
            }

            let diff = _.difference(allFiles, existingFiles);
            let done = true;
            for (let j = 0; j < diff.length; j++) {
                // Check for file existence
                done = false;
                fileSet[diff[j]] = 'missing';
            }
            if (done) {
                R.end(req, 'parsePass1');
                def.resolve(fileSet);
            } else {
                R.end(req, 'parsePass1');
                parsePass1(archive, options, fileSet).then(function() {
                    def.resolve(fileSet);
                }, function(err) {
                    def.reject(err);
                });
            }
        }
    }, function(err) {
        R.end(req, 'parsePass1', err);
        def.reject(err);
    });
    return def.promise;
}

function parsePass2(archive, fileSet, options) {
    let isExecutable = false;
    let req = options.req;
    let files = [];
    let def = q.defer();
    R.start(req, 'parsePass2');
    fileUtils.pipeArchive(archive, req,

    function(fileName, mode, req) {
        // Return true to ignore the file (silently)
        // Throw an error if invalid file.
        isExecutable = fileUtils.isExecutable(mode);
        if (fileUtils.isSymbolicLink(mode)) {
            throw g.http(u.r(req)).Error('A file for a symbolic link was encountered in the zip.  Remove the file %s.', fileName);
        }
        if (fileUtils.isMACOSX(fileName) || fileUtils.isDirectory(fileName)) {
            return true; // silently ignore
        }
        if (fileUtils.isXSD(fileName) || fileUtils.isWSDL(fileName) || fileUtils.isXML(fileName) || fileUtils.isConfig(fileName)) {
            return !fileSet[fileName];  // Ignore files that are not in the calculated fileSet.
        }

        if (!options.allowExtraFiles) {
            throw g.http(u.r(req)).Error('Only .xsd and .wsdl files are allowed in the zip.  Remove the file %s.', fileName);
        }
        return true;

    },

    function(fileName, content, req) {
        // Process the decoded content of the file.
        R.start(req, 'parse2: ' + fileName);
        let ret = {
            fileName: fileName,
            fileContent: null, // Set only if content should be changed in the output archive
        };
        if (fileUtils.isConfig(fileName)) {
            let opts = jsyaml.safeLoad(content, 'utf8');
            options.config = opts;
            return null;  // Don't put the config in the output archive
        }
        try {
            var shortName = fileName;
            var index = shortName.lastIndexOf('/');
            if (index != -1) {
                shortName = shortName.substr(index + 1);
            }

            // Create a file entry for allWSDLs
            var file = {
                filename: shortName,
                fullName: fileName,
                type: 'wsdl', // temp for now determined later when we actually parse it
                content: content,
                context: 'zip'
            };

            try {
                // For legacy reasons, it is possible that an xml file has schema.
                // If this xml file does not have schema then don't allow it.
                if (fileUtils.isXML(fileName)  && content.indexOf('schema') < 0) {
                    throw g.http(u.r(req)).Error('Only .xsd and .wsdl files are allowed in the zip.  Remove the file %s.', fileName);
                }
                parseUtils.contentToXMLorWSDL(file, options);
                delete file.content;
            } catch (e) {
                // If the file is not a wsdl, then save the error
                // and rethrow later only if it is is included or imported
                // We do this for migration reasons.
                if (fileUtils.isWSDL(fileName)  || isExecutable) {
                    throw e;
                } else {
                    file.error = e;
                    file.type = 'xsd';
                }
            }
            let valid = false;
            if (file.error) {
                files.push(file);
            } else if (file.json.definitions) {
                let checkWSDL = parseUtils.validateWSDLJson(file.json, file.filename);
                if (checkWSDL.valid) {
                    files.push(file);
                    file.type = 'wsdl';
                    var namespaces = file.doc.definitions.xmlns;
                    file.namespaces = namespaces;
                    valid = true;
                } else {
                    throw new Error(checkWSDL.reason);
                }
            } else if (file.json.schema) {
                files.push(file);
                file.type = 'xsd';
                file.namespaces = {};
                valid = true;
            } else {
                // Cannot parse the wsdl or xsd file.
                // If this is a wsdl then fail fast.
                // Else the error is saved and only issued if this file is needed
                let e = g.http(u.r(req)).Error('Failed to parse wsdl or xsd in file %s.', file.filename);
                if (fileUtils.isWSDL(fileName)) {
                    throw e;
                } else {
                    file.error = e;
                    file.type = 'xsd';
                    files.push(file);
                }
            }
            // have to capture the service children elements (ports) here as they get munged later
            if (valid) {
                file.serviceChildren = postParse.captureServiceChildren(file.doc);
                postParse.updateSchemaNamespaces(file, req);
            }
        }  catch (e) {
            if (fileUtils.isXML(fileName)) {
                throw g.http(u.r(req)).Error('Only .xsd and .wsdl files are allowed in the zip.  Remove the file %s.', fileName);
            }
            throw e;
        }
        R.end(req, 'parse2: ' + fileName);
        return ret;
    }).then(function(out) {
        // Collect any localized fatal errors from the file processing, and reject if any found
        let messages = [];
        for (let i = 0; i < out.files.length; i++) {
            if (out.files[i].error) {
                messages.push(out.files[i].fileName + ': ' + out.files[i].error.message);
            }
        }
        if (messages.length > 0) {
            let error = new Error(messages.join('\n'));
            R.end(req, 'parsePass2', error);
            def.reject(error);
        } else {
            R.end(req, 'parsePass2');
            def.resolve({
                files: files,
                archive: out.archive.content
            });
        }
    }, function(err) {
        def.reject(err);
    });
    return def.promise;
}

exports.getJsonForWSDL = getJsonForWSDL;
exports.getWSDLServices = getWSDLServices;
exports.getWSDLServicesAll = getWSDLServicesAll;
exports.findWSDLForServiceName = findWSDLForServiceName;
exports.sanityCheckDefinition = sanityCheckDefinition;
