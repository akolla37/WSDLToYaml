/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2019
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const d = require('../lib/domUtils.js');
const fileUtils = require('../lib/fileUtils.js');
const R = require('../lib/report.js');



/* Utilities for parsing the WSDL/XSD files for apiconnect-wsdl */

var _ = require('lodash');
const q = require('q');
const url = require('url');
const soap = require('soap');
const xmldom = require('xmldom');
// var g = require('strong-globalize')();
const g = require('../lib/strong-globalize-fake.js');

// monkey patch soap WSDL parser
soap.WSDL.prototype.processIncludes = function(callback) {
    if (this.definitions) {
        var schemas = this.definitions.schemas;
        var includes = [];
        var schemaWithoutTargetNamespace = false;

        for (var ns in schemas) {
            var schema = schemas[ns];
            if (ns == 'undefined') {
                schemaWithoutTargetNamespace = true;
            }
            includes = includes.concat(schema.includes || []);
        }
        try {
            this._processNextInclude(includes, callback);
        } catch (e) {
            // Schemas should have a targetNamespace according to WS-I
            // Normally a schema without a targetNamespace is simply used to import other schemas (which is fine)
            // But if the schema contains elements, types etc, then soap.WSDL processing may fail.
            // Continue processing in such cases to avoid regressions.
            if (schemaWithoutTargetNamespace) {
                // R.info(g.http(null).f('A \'schema\' element does not have a \'targetNamespace\' attribute. The missing targetNamespace is ignored and processing continues.  The ignored error is (%s).', e));
            } else {
                // An exception involving postProcess occurs if a wsdl:operation references a missing wsdl:message
                // Don't save the message because we do a more thorough check later.
                // Save other internal messages
                if (!e.message || e.message.indexOf('postProcess') < 0) {
                    this.internalError = e;
                }
            }
            if (callback) {
                callback(e, this);
            }
        }
    }
};

// monkey patch soap WSDL parser
soap.WSDL.prototype._fromXML = function(xml) {
    if (xml && xml.length > 0) {
        this.definitions = this._parse(xml);

        if (this.definitions) {
            this.definitions.descriptions = {
                types: {}
            };
        }
        this.xml = xml;
    }
};

/**
* Wrapper around _fromXML that ammends the error message; thus the error message
* provides contextual information for the customer.
*/
function fromXML(obj, content, context, req) {
    try {
        obj._fromXML(content);
    } catch (e) {
        var insertContent = content.length < 300 ? content : content.substring(0, 300);
        context = context.toString();
        var insertContext = context.length < 300 ? context : context.substring(0, 300);
        // The location of the error is separately translated so that it can be removed in some cases.
        let where = g.http(u.r(req)).f('An error occurred while parsing "%s".\n', fileUtils.escape(insertContext));
        // throw g.http(u.r(req)).Error('%s The error is (%s).\n The content starts with [%s].', where, cleanupError(e, req), escape(insertContent));
        let msg = g.http(u.r(req)).f('%s The error is (%s).\n The content starts with [%s].', where, fileUtils.cleanupError(e, req), fileUtils.escape(insertContent));
        throw new Error(msg);
    }
}

/**
* preParse the xml file content.
* Prior to parsing the file with node soap, the file is parsed with an ordinary
* DOM Parser to do some fixups.
*
* 1) Add fake targetNamespaces if a schema lacks a TargetNamespace
* 2) Add special ids to choice, sequence, etc. because node soap does not preserve their order.
*    These ids will be used in the generation pass to ensure the constructs are properly ordered.
* 3) Remove certain wsdl documentation elements.  These are unnecessary and cause problems in the node
*    soap parser.
* 4) Look for DTDs and other fatal node types
*/
function preParse(fileContent, fileName, options) {
    let req = options.req;
    let doc = d.loadDOM(fileContent);
    if (!doc) {
        return fileContent;
    }

    // If a schema does not have a targetNamespace, add a fake one
    // Often wsdl files will have schemas without a targetnamespace simply to import other schemas.
    // These schemas can cause error messages during parsing, so we add fake namespaces to avoid
    // error messages (and other relate problems).
    R.start(req, 'tgtNS:' + fileName);

    let faketnsID = 0;
    let schemas = doc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'schema');
    for (var s = 0; s < schemas.length; s++) {
        let schema = schemas[s];
        if (!schema.getAttribute('targetNamespace')) {
            if (faketnsID == 0) {
                // Only add fakens if multiple schemas...updating the schema for just one instance
                // is not necessary and affects performance because we need to do a serialization
                // of this doc
                faketnsID++;
            } else {
                schema.setAttribute('targetNamespace', 'https:/APICTNS' + faketnsID++);
            }
        }
    }
    schemas = null;
    R.end(req, 'tgtNS:' + fileName);

    R.start(req, 'docRemove:' + fileName);

    // Find wsdl documentation elements in types and definition
    let wsdlDocs = [];
    let wsdlDocs2 = [];
    let wsdlDef = doc.getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'definitions');
    if (wsdlDef && wsdlDef.length > 0) {
        // Remove wsdl:documentation within types
        let wsdlTypes = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'types');
        if (wsdlTypes && wsdlTypes.length > 0) {
            wsdlDocs = wsdlTypes[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'documentation');
        }

        // Remove wsdl:documentation under definitions, but only if there is NO wsdl:service
        let wsdlService = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'service');
        if (!wsdlService || wsdlService.length === 0) {
            wsdlDocs2 = wsdlDef[0].getElementsByTagNameNS('http://schemas.xmlsoap.org/wsdl/', 'documentation');
        }
    }

    // Remove documentation elements because node/soap does not like them, but the spec says they are allowed.
    for (let i = 0; i < wsdlDocs.length; i++) {
        let wsdlDoc = wsdlDocs[i];
        wsdlDoc.parentNode.removeChild(wsdlDoc);
    }
    for (let i = 0; i < wsdlDocs2.length; i++) {
        let wsdlDoc = wsdlDocs2[i];
        if (wsdlDoc.parentNode &&
            wsdlDoc.parentNode.namespaceURI === 'http://schemas.xmlsoap.org/wsdl/' &&
            wsdlDoc.parentNode.localName === 'definitions') {
            wsdlDoc.parentNode.removeChild(wsdlDoc);
        }
    }
    wsdlDocs = [];
    wsdlDocs2 = [];
    wsdlDef = [];
    R.end(req, 'docRemove:' + fileName);


    R.start(req, 'scan:' + fileName);

    // Walk the DOM looking for DOCTYPE and other unrecognized node types
    let badNames = [];
    let ALLOW_NMTOKEN = {
        definitions: true,
        part: true,
        input: true,
        output: true,
        fault: true,
    };
    let elementCount = 0;
    d.traverseDOM(doc, function(node, stack) {
        let info = d.getNodeTypeInfo(node.nodeType);
        if (node.nodeType === 1) {
            elementCount++;
        }
        if (info.report) {
            throw g.http(u.r(req)).Error('Found a node type of %s within file %s.  This is not supported.', info.name, fileName);
        }
        if (node.nodeName) {
            // Don't need appinfo or comments in the backend, and we don't want to parse its contents.  So remove it.
            if (node.localName === 'appinfo') {
                node.parentNode.removeChild(node);
                node = null;
            } else if (node.nodeName === '#comment') {
                node.parentNode.removeChild(node);
                node = null;
            }
            if (node && node.nodeType == 1) {
                // Enforce NMTOKEN or NCNames to prevent weird problems in backend.
                let name = node.getAttribute('name');
                if (name && node.namespaceURI) {
                    // Enforce compliance if namespaces is for a specification that the generator processes.
                    let info = d.getNamespaceInfo(node.namespaceURI);
                    if (info.base || info.extension) {
                        let valid = ALLOW_NMTOKEN[node.localName] ? u.isNMTOKEN(name) : u.isNCName(name);
                        if (!valid && _.indexOf(badNames, name) < 0) {
                            badNames.push(name);
                        }
                    }
                }

                // Make sure first node is a definitions or schema elements
                if (elementCount === 1) {
                    if (node.localName !== 'schema' && node.localName !== 'definitions') {
                        if (node.localName === 'description') {
                            throw g.http(u.r(req)).Error('Found a WSDL 2.0 description element in %s.  Only WSDL 1.1 and WSDL 1.2 are supported.', fileName);
                        } else {
                            throw g.http(u.r(req)).Error('Expected \'schema\' or \'definitions\' element but found \'%s\' in %s.  Please correct the WSDL or XSD file.', fileName);
                        }
                    }
                }
            }
        }
        return node;
    });

    if (badNames.length > 0) {
        throw g.http(u.r(req)).Error('Found xml name(s) that are not valid xml NCNames [ %s ] within file %s.  This is not supported.', badNames, fileName);
    }
    R.end(req, 'scan:' + fileName);

    R.start(req, 'prune:' + fileName);

    // Look for unknown or uncommon elements and names.  These are reported as detail messages.
    let map = d.getNamesMap(doc);
    if (map.nsMap['xml']) {
        R.info(req, g.http(u.r(req)).f('Found declaration xmlns:xml in file %s.  This is a violation of a WS-I Rule (R4005 A DESCRIPTION SHOULD NOT contain the namespace declaration xmlns:xml="http://www.w3.org/XML/1998/namespace").  Processing continues.', fileName));
    }
    let errNodes = [];
    let errAttrs = [];
    for (let key in map.nodes) {
        let info = d.getNameInfo(key);
        if (!info.known) {
            R.detail(req, g.http(u.r(req)).f('Found unknown NCName %s in file %s', key, fileName));
        } else if (!info.common) {
            R.detail(req, g.http(u.r(req)).f('Found uncommon NCName %s in file %s.  This uncommon name is associated with %s', key, fileName, info.ns));
        }
    }
    let unknownAttrCount = 0;
    for (let key in map.attrs) {
        let info = d.getAttrInfo(key);
        if (!info.known && unknownAttrCount < 100) {
            R.detail(req, g.http(u.r(req)).f('Found unknown attribute %s in file %s', key, fileName));
            unknownAttrCount++;
        } else if (!info.common) {
            R.detail(req, g.http(u.r(req)).f('Found uncommon attribute %s in file %s.  This uncommon name is associated with %s', key, fileName, info.ns));
        }
    }

    // Remove all unknown elements from the DOM, also add apicID attributes (which are used to preserve ordering)
    doc = d.pruneAndAddID(doc);
    R.end(req, 'prune:' + fileName);

    // Make sure the wsdl or xsd syntax is correct.
    // We don't want invalid wsdl or schema to enter the genrate processing.
    R.start(req, 'syntaxCheck:' + fileName);
    d.syntaxCheck(doc, fileName, req);
    R.end(req, 'syntaxCheck:' + fileName);


    R.start(req, 'serialize:' + fileName);

    // Serialize the updated doc
    let serializer = new xmldom.XMLSerializer();
    fileContent = serializer.serializeToString(doc);
    // Comments are encoded by the serializer, so we need to do a replace
    fileContent = fileContent.replace(/&lt;!-/g, '<!-');
    R.end(req, 'serialize:' + fileName);

    return fileContent;
}



// Check for oddities in the WSDL json produced by node soap
function validateWSDLJson(wsdlJson, filename, req) {
    var ret = {
        valid: true
    };
    if (wsdlJson && wsdlJson.definitions) {
        if (wsdlJson.definitions.types) {
            if (Array.isArray(wsdlJson.definitions.types)) {
                // not valid to have more than one wsdl:types entry
                ret.valid = false;
                ret.reason = g.http(u.r(req)).f('A wsdl \'document\' must not contain more than one \'wsdl:types\' element. The file is %s.', filename);
            }
        }
        var correct = checkParentage(wsdlJson.definitions.types, 'types', 'extension', [ 'simpleContent', 'complexContent' ]);
        if (!correct) {
            ret.valid = false;
            ret.reason = g.http(u.r(req)).f('An \'extension\' element must be a child of a \'simpleContent\' or \'complexContent\' element. The file is %s.', filename);
        }
    } else if (wsdlJson && !wsdlJson.definitions) {
        ret.valid = false;
        ret.reason = g.http(u.r(req)).f('A wsdl \'document\' does not contain any valid content. The file is %s.', filename);
    }
    return ret;
}

/**
* Common utility function that converts raw content (file.content)
* into node soap (file.doc and file.json).
*/
function contentToXMLorWSDL(file, options) {
    let req = options.req;
    R.start(req, 'quickFix:' + file.filename);

    // Do some string replace fixups (the DOM is not loaded)
    // fix some ideosyncracies with tag whitespace
    // protect documentation in CDATA
    file.content = u.fixTags(file.content);
    file.content = d.protectDocumentation(file.content);
    R.end(req, 'quickFix:' + file.filename);

    R.start(req, 'preParse:' + file.filename);
    // Now do a preParse pass (which loads and checks the DOM)
    file.content = preParse(file.content, file.filename, options);
    R.end(req, 'preParse:' + file.filename);

    R.start(req, 'nodeSOAP:' + file.filename);
    // Now convert to XML/WSDL a second time with the adjusted data.
    file.doc = new soap.WSDL('', file.filename, {});
    fromXML(file.doc, file.content, file.filename, req);
    file.json = file.doc.xmlToObject(file.content);
    R.end(req, 'nodeSOAP:' + file.filename);
}


// Utility to check if objects with the name (elementName) only
// has parents whose name is in the validParents array.
function checkParentage(root, rootName, elementName, validParents) {
    var ret = true;
    if (root && rootName && elementName && validParents) {
        for (var name in root) {
            if (name == elementName) {
                if (validParents.indexOf(rootName) == -1) {
                    ret = false;
                    break;
                }
            }
            var item = root[name];
            if (item && typeof item === 'object') {
                var entries = u.makeSureItsAnArray(item);
                var len = entries.length;
                for (var i = 0; i < len; i++) {
                    var entry = entries[i];
                    ret = checkParentage(entry, name, elementName, validParents);
                    if (!ret) {
                        break;
                    }
                } // end for
                if (!ret) {
                    break;
                }
            }
        } // end for
    }
    return ret;
}

exports.contentToXMLorWSDL = contentToXMLorWSDL;
exports.validateWSDLJson = validateWSDLJson;
